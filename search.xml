<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GMM-UBM 确认系统</title>
      <link href="/2019/10/30/GMM-UBM%20%20%E7%A1%AE%E8%AE%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/10/30/GMM-UBM%20%20%E7%A1%AE%E8%AE%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="gmm-ubm-确认系统"><a class="markdownIt-Anchor" href="#gmm-ubm-确认系统"></a> GMM-UBM  确认系统</h1><p>​一个重要的步骤是对实际似然函数的选取。这个函数的选取很大程度上取决于特征和所应用场景的特性【specifics of the application】。对于文本无关场景中，最成功的的函数一直是高斯混合模型。在文本相关的应用中，由于口语文本具有很强的先验知识，可以使用隐马尔可夫模型(HMMs)来合并额外的时间知识【temporal knowledge】。且在文本无关方面，HMMs并没显示出比GMM更好的优势。</p><p>对于D维的特征向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> ,用于似然函数的混合概率密度表示为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi mathvariant="bold-italic">x</mi><mi mathvariant="normal">∣</mi><mi>λ</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><msub><mi>w</mi><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi mathvariant="bold-italic">x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(\boldsymbol{x} | \lambda)=\sum_{i=1}^{M} w_{i} p_{i}(\boldsymbol{x})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord boldsymbol">x</span></span></span><span class="mord">∣</span><span class="mord mathdefault">λ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.106005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord boldsymbol">x</span></span></span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi mathvariant="bold-italic">x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>π</mi><msup><mo stretchy="false">)</mo><mrow><mi>D</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><msup><mrow><mo fence="true">∣</mo><msub><mi mathvariant="normal">Σ</mi><mi>i</mi></msub><mo fence="true">∣</mo></mrow><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup></mrow></mfrac><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">{</mo><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mrow><mo fence="true">(</mo><mi mathvariant="bold-italic">x</mi><mo>−</mo><msub><mi mathvariant="bold-italic">μ</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow><mo mathvariant="normal">′</mo></msup><msup><mrow><mo fence="true">(</mo><msub><mi mathvariant="normal">Σ</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo fence="true">(</mo><mi mathvariant="bold-italic">x</mi><mo>−</mo><msub><mi mathvariant="bold-italic">μ</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">p_{i}(\boldsymbol{x})=\frac{1}{(2 \pi)^{D / 2}\left|\Sigma_{i}\right|^{1 / 2}} \exp \left\{-\frac{1}{2}\left(\boldsymbol{x}-\boldsymbol{\mu}_{i}\right)^{\prime}\left(\Sigma_{i}\right)^{-1}\left(\boldsymbol{x}-\boldsymbol{\mu}_{i}\right)\right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord boldsymbol">x</span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.6178999999999997em;vertical-align:-1.1679em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.0279em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.814em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0279em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.2579em;"><span class="pstrut" style="height:3.0279em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7049em;"><span class="pstrut" style="height:3.0279em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1679em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">exp</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord"><span class="mord boldsymbol">x</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">μ</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.21752399999999997em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.891792em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord"><span class="mord boldsymbol">x</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">μ</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.21752399999999997em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">}</span></span></span></span></span></span></span></p><p>而一般模型形式支持全协方差矩阵，即一个包含所有元素的协方差矩阵，本文只使用对角协方差矩阵。这样做有三个原因：</p><ol><li>首先，一个m阶全协方差GMM的密度模型同样可以用一个更大的阶对角协方差GMM来实现。</li><li>其次，对角矩阵GMMs比全协方差GMMs在训练方面的计算效率更高，因为不需要对一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>×</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">D \times D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span>矩阵进行重复倒转。</li><li>第三，经验表明，对角矩阵GMMs优于全矩阵GMMs。</li></ol><p>​     在给定一组训练向量的情况下，利用迭代期望极大化算法(EM)对最大似然模型参数进行估计。EM算法迭代地将GMM参数给细化(refine)，通过<strong>单调地</strong>增加估计模型的可能性，即，对于迭代$ k和k+1 $, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>A</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&gt;</mo><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>A</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(X|A(k+1) &gt;p(X |A(k))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。<strong>一般来说，五次迭代就足以使参数收敛。<strong>训练GMM的EM方程可在[3,18]中找到。如后面讨论的，使用 EM 算法去训练UBM的参数，但是使用</strong>贝叶斯自适应算法 <strong>[Bayesian adaptation] 去训练</strong>$Speaker models $</strong></p><p>​通常情况下 X 被视作独立，所以对于特征向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>=</mo><mrow><mo fence="true">{</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>T</mi></msub><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">X=\left\{x_{1}, \dots, x_{T}\right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span>的模型 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span> 的对数似然率，可被如下计算：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>λ</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></munderover><mi>log</mi><mo>⁡</mo><mi>p</mi><mrow><mo fence="true">(</mo><msub><mi mathvariant="bold-italic">x</mi><mi>t</mi></msub><mi mathvariant="normal">∣</mi><mi>λ</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\log p(X | \lambda)=\sum_{t=1}^{T} \log p\left(\boldsymbol{x}_{t} | \lambda\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault">λ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0954490000000003em;vertical-align:-1.267113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">x</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault">λ</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mrow><mo fence="true">(</mo><msub><mi mathvariant="bold-italic">x</mi><mi>t</mi></msub><mi mathvariant="normal">∣</mi><mi>λ</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">p\left(\boldsymbol{x}_{t} | \lambda\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">x</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault">λ</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span>已经在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>q</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Eq.(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord">.</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>被计算。通常，平均对数似然值是用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">logp(X |A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mclose">)</span></span></span></span>除以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>来计算的。由于不正确的独立性假设低估了实际的似然值与依赖关系，因此在式(3)中，这个比例因子也可以看作是对似然值的一个粗略补偿因子。</p><p>​GMM 可以看作是参数密度模型和非参数密度模型的混合。与参数模型类似，它具有结构和参数，这些结构和参数以已知的方式控制密度的行为，但没有数据必须是特定分布类型(如高斯分布或拉普拉斯分布)的约束。与非参数模型相似，GMM 具有许多自由度，允许任意密度建模，而不需要过多的计算和存储。它也可以被认为是具有高斯混合观测密度的单态隐马尔可夫模型，或者具有固定的、等转移概率的遍历高斯观测隐马尔可夫模型。在这里，高斯分量可以被认为是在模拟一个人声音的基本语音特征。关于 GMMs 如何应用于说话人建模的更详细的讨论可以在[2,3]中找到。</p><p>​使用 GMM 的似然函数的优点是计算便宜,是基于一个易于理解的统计模型,对于text-independent任务,在时间方面不敏感，仅对来自说话者的**声学观察[acoustic observations] **的潜在分布建模。后者也有一个缺点，即不使用时间语音信号中所传达的关于说话人的更高层次的信息。对这些高层次信息的建模和利用可能是基于语音识别[19]的方法在未来产生效益的地方。然而，到目前为止，这些方法(例如，大规模词汇或者音素识别器【recognizers】)基本上只被用作计算似然值的方法，而没有明显地使用任何高级信息，例如依赖于说话者的单词使用情况或说话风格。</p><h2 id="33-universal-background-model"><a class="markdownIt-Anchor" href="#33-universal-background-model"></a> 3.3  Universal Background Model</h2><p>​在GMM-UBM 系统中，我们使用单独的，说话人无关的北京模型去表征<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mrow><mo fence="true">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>λ</mi><mfrac><mrow></mrow><mrow><mi mathvariant="normal">h</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi></mrow></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">p\left(X | \lambda \frac{ }{\mathrm{hyp}}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.80002em;vertical-align:-0.65002em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault">λ</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.394em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">h</span><span class="mord mathrm mtight" style="margin-right:0.01389em;">y</span><span class="mord mathrm mtight">p</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span></span> 。UBM就是一个大型的被训练去表征说活人无关特征分布的 GMM。Specifically, we want to select speech that is reflective of the expected alternative speech to be encountered during recognition。</p><p>​经验上看，用六小时的语音去训练UBM与用一小时的语音训练UBM没有明显的差异。</p><p>​考虑去训练UBM的数据，有很多中方法可以被使用来去得到最终的模型。最简单的方法就是通过EM算法用所有的data去训练UBM。需要注意的是，池中的数据在数据中的子总体应当是平均的。例如，在使用性别无关的数据时，应当保持男女数量的平等，否则最终的结果会偏向具有子总体占比较多的部分。</p><p><img alt="1557407755116" data-src="C:%5CUsers%5Cwangj%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557407755116.png" class="lozad"></p><p>产生 UBM 的方法有两种：</p><ol><li>把所有的次总体【subpopulation】的数据全放到池中去训练UBM【EM算法】</li><li>各个次总体被单独计算，然后再组合在一起。</li></ol><h2 id="34-adaptation-of-speaker-model"><a class="markdownIt-Anchor" href="#34-adaptation-of-speaker-model"></a> 3.4  Adaptation  of  Speaker Model</h2><p>​在GMM-UBM 的系统中，我们获得假定的说话人模型，通过调节UBM的参数，使用说话人训练语音和一种贝叶斯适应算法。[18,27]。不像标准的方法，最基本的观点在适应方法中通过更新UBM中已经训练好的参数。这提供了一种更加紧密的联系在说话人模型和UBM之间，它不仅仅比起解耦模型产生更好的表现，而却允许快速评分的技术。像EM算法，adaption 有两个估计过程。第一步，相当于EM算法中的E-step，通过计算UBM的每个混合来评估说话人训练数据的充分统计量【sufficient statistics】，就是一旦知道这些量的时候,这个分布也就确定了。这些新的充分统计量与那些老的统计量通过一个数据相关融合系数【data-dependent mixing coefficient】combine 在一起。</p><p>​这个数据相关融合系数被设计：来自说话人的 high counts of data 更多取决与新充分统计量，而 low counts of data 更多取决于旧充分统计量。</p><p>​具体内容如下。给定假设说话者的UBM和训练向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>=</mo><mrow><mi>x</mi><mn>1</mn><mi mathvariant="normal">，</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">，</mi><mi>r</mi></mrow></mrow><annotation encoding="application/x-tex">X={x1，..，r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord">.</span><span class="mord">.</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span></span>，首先确定训练向量对UBM混合分量的概率比对(图3a)。也就是说，对于UBM中的混合物i，我们计算</p>]]></content>
      
      
      <categories>
          
          <category> Sports </category>
          
          <category> Baseball </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MFCC提取过程详解</title>
      <link href="/2019/10/30/MFCC%E6%8F%90%E5%8F%96%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/10/30/MFCC%E6%8F%90%E5%8F%96%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="mfcc提取过程详解"><a class="markdownIt-Anchor" href="#mfcc提取过程详解"></a> MFCC提取过程详解</h1><h2 id="mfcc是什么"><a class="markdownIt-Anchor" href="#mfcc是什么"></a> MFCC是什么？</h2><p>MFCCs是一个在语音识别和说话者识别领域被广泛运用的特征，由Davis和Mermelstein在1980年提出，可以说从那以后，MFCCs就一直占据这声音特征方面的state-of-the-art。这篇文章主要介绍MFCCs的提取过程以及为什么MFCCs对声音特征的表达会这么好。</p><blockquote><ul><li>1980年，Davis和Mermelstein等人通过对梅尔滤波器的研究，发现了梅尔频率倒谱系数（Mel Frequency Cepstral      Coefficients，MFCC）。随着MFCC特征参数及其衍生参数被多数学者所接受，因此科研人员开始利用MFCC特征参数的[模板匹配算法](onenote:#模板匹配算法&amp;section-id={73EF26E9-19C0-4F9B-BA6F-A390C8851415}&amp;page-id={C5C29020-9E63-46A5-9AF4-66EF181B1967}&amp;object-id={D860292A-AF59-4E81-A130-C547AE0A495B}&amp;27&amp;base-path=https://d.docs.live.net/ff6497e48aac00f1/文档/2019-2020 研究生二年级（上）/论文阅读.one)提高说话人的识别效率。</li></ul></blockquote><p>提取：</p><p>预处理过程包括：预加重、分帧和加窗函数。</p><p>预加重的目的：就是在于弥补发音系统所抑制的高频分量的损失，这个与发生机理有关，有理论认为声门脉冲的频率响应曲线接近于一个二阶低通滤波器，而口腔的辐射响应也接近于一个一阶高通滤波器。其次，高频段信号能量明显小，预加重后可以使信号的频谱更加趋近与平缓，之后能够用相同的信噪比去对频谱进行处理。</p><p>操作：通过一个高通滤波器。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><mi>μ</mi><msup><mi>z</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">H(z)=1-\mu z^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>,其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>通常取介于0.9-1.0之间，我们通常取0.97。</p><p>语音信号是一个非稳态、时变的信号，但是经过分帧处理后，在某个“短时间”的范围内可以认为信号是稳态的，通常我们取20-40m为一帧的宽度。结合TIMIT数据集，对语音信号分析发现这里选择25ms作为一帧能够更好的反映出信号处理的短时平稳特征，如图所示，保证了一个帧内含有2到3个周期的信号波动。</p><p><img alt="1568894232165" data-src="C:%5CUsers%5Cwangj%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1568894232165.png" class="lozad"></p><p>对每一帧进行加窗。加窗的目的是平滑信号，使用汉宁窗加以平滑的话，相比于矩形窗函数，会减弱FFT以后旁瓣大小以及频谱泄露，至于窗函数的类型影响不是很重要。从上面的例子可以看出来，如果不进行加窗，那么某一帧的结束值和下一帧的开始值会有一个跳跃现象存在。</p><ol start="3"><li><p>对每一帧进行离散傅里叶变换（DFT）目的：</p><ol><li>在于由于信号在时域上的变换通常很难看出信号的特性，所以通常将它转换为频域上的能量分布来观察，不同的能量分布，就能代表不同语音的特性。并对语音信号的频谱取模平方得到语音信号的功率谱。<strong>能量谱（幅度谱平方）</strong>— 功率谱的周期图估计</li></ol></li><li><p>三角带通滤波器：（模仿人耳）接将所有频点 （N维）能量作为特<strong>征有非常大的冗余</strong>（理解了！！），因为<strong>听觉掩蔽</strong>效应许多相邻频率对人耳作用结果相似，因此通常用少量filterbank将频域划分成少量子带（比如24个filterbank，这些子带在mel频域是均匀划分的，相邻子带有一半重叠，在自然频域则是低频窄高频宽)，每个子带输出子带能量和作为特征表征该频率段的能量水平，这样就得到24个特征。</p><p>（This is a set of 20-40 (26 is standard) triangular filters that we apply to the periodogram power spectral estimate from step 2. Our filterbank comes in the form of 26 vectors of length 257 (assuming the FFT settings fom step 2)</p><p><img alt="1568897160126" data-src="C:%5CUsers%5Cwangj%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1568897160126.png" class="lozad"></p><p>计算mel倒谱bank的来龙去脉：（也有不用转换的，直接代公式去执行）</p><ol><li><p>300-800 之间有10个滤波器</p></li><li><p>转换到Mel域，等分10份，再转回到 正常的时域</p></li><li><p>We don’t have the frequency resolution required to put filters at the exact points calculated above, so we need to round those frequencies to the nearest FFT bin. This process does not affect the accuracy of the features. To convert the frequncies to fft bin numbers we need to know the FFT size and the sample rate</p><ol start="4"><li>We can see that the final filterbank finishes at bin 256, which corresponds to 8kHz with a 512 point FFT size.</li><li><img alt="1568909334929" data-src="C:%5CUsers%5Cwangj%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1568909334929.png" class="lozad"></li></ol><p><img alt="Plot of 10 filter Mel Filterbank" data-src="http://practicalcryptography.com/media/miscellaneous/files/10_filt_melfb.png" class="lozad"></p></li></ol></li><li><p>对24个子带求对数，对数的作用普遍认为有两个，第一个就是对压缩频谱的动态范围，第二个就是使得频域的卷积信号变成加性，通过筛选特征系数，（相当于进行了一次低通滤波），将声源激励和声道信号区分开来。</p><p>以上可以几个流程可以总结为式子为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></munderover><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><msub><mi>H</mi><mi>m</mi></msub><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>m</mi><mo>&lt;</mo><mo>=</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">S_m(k)=ln(\sum_{k=0}^{N-1}|X(k)|^2H_m(k)),0&lt;=m&lt;=M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1304490000000005em;vertical-align:-1.302113em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></span></p></li><li><p>DCT的目的：</p><ol><li>为去除不同维度信号间的相关性，将信号映射到低纬度的向量空间，运用孤立向量减小特征参数间的维度，以减少运算时间。<strong>对M个对数能量谱进行离散余弦变换（Discrete Cosine Transform，DCT）</strong>，则S（m）经DCT变换后，得到MFCC特征参数</li><li>我的看法是：相当于做了IFFT变换，从频域进入伪频域，（单位是时间），提取前面的几个系数</li></ol></li></ol><p>差分特性（Delta and Delta-Delta）</p><p>：通常也被称为差分（Differential）和加速度（acceleration）系数。MFCC特征向量仅仅描述了单帧的功率谱包络，但是仍有很多的信息保存在动态特征中。通常取12个系数，如果加了一个动态特征就是24为特征。</p><p>注：但是到底要不要丢掉第一维特征，一直没有一个统一的说法，需要继续测试。</p><p>为了继续去计算delta系数，公式为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>t</mi></msub><mo>=</mo><mfrac><mrow><msubsup><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><mi>n</mi><mo stretchy="false">(</mo><msub><mi>c</mi><mrow><mi>t</mi><mo>+</mo><mi>n</mi></mrow></msub><mo>−</mo><msub><mi>c</mi><mrow><mi>t</mi><mo>−</mo><mi>n</mi></mrow></msub><mo stretchy="false">)</mo></mrow><mrow><mn>2</mn><msubsup><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><msup><mi>n</mi><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">d_t = \frac{\sum_{n=1}^N n(c_{t+n}-c_{t-n})}{2\sum_{n=1}^{N}n^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.8330440000000001em;vertical-align:-0.654672em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.178372em;"><span style="top:-2.570335em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8852357142857143em;"><span style="top:-2.1785614285714283em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.8971428571428572em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32143857142857146em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5350070000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9190928571428572em;"><span style="top:-2.1785614285714283em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32143857142857146em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.29634285714285713em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.20252142857142857em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.29634285714285713em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.20252142857142857em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.654672em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">d_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是一阶差分系数，t代表帧，通常来首N取为2。Delta-Delta (Acceleration) coefficients are calculated in the same way, but they are calculated from the deltas, not the今天系数</p>]]></content>
      
      
      
        <tags>
            
            <tag> MFCC 语音识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab绘图（二）低频率命令总结</title>
      <link href="/2019/10/29/Matlab%E7%BB%98%E5%9B%BE%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BD%8E%E9%A2%91%E7%8E%87%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/29/Matlab%E7%BB%98%E5%9B%BE%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BD%8E%E9%A2%91%E7%8E%87%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="matlab绘图二低频率命令总结"><a class="markdownIt-Anchor" href="#matlab绘图二低频率命令总结"></a> Matlab绘图（二）低频率命令总结</h1><p>Matlab的绘图有些操作用的频率很少，所以每次用每次忘，而且这些指令根本没有记忆的必要性，除了基础的画图操作外，有大部分的命令明显可通过matlab图像编辑窗进行快速操控（如添加colorbar，添加annotation等，如截图保存图片等）。</p><p>但是这些操作遇到批量处理（如批量存储图片）,或者GUI设计这些操作又不得不去使用。</p><h2 id="1-plot额外属性设置"><a class="markdownIt-Anchor" href="#1-plot额外属性设置"></a> 1. plot额外属性设置</h2><p><img alt data-src="https://img2018.cnblogs.com/blog/1553593/201910/1553593-20191025163047856-2015509147.png" class="lozad"></p><p><img alt data-src="https://img2018.cnblogs.com/blog/1553593/201910/1553593-20191025163153931-543246138.png" class="lozad"></p><h2 id="2-legend-设置"><a class="markdownIt-Anchor" href="#2-legend-设置"></a> 2. legend 设置</h2><p>详细介绍的博客：<a href="https://www.cnblogs.com/lihuidashen/p/3443526.html" target="_blank" rel="noopener">https://www.cnblogs.com/lihuidashen/p/3443526.html</a></p><p>基本用法：<code>legend(string1,string2,string3, ...)</code></p><p>设置legend的位置： <code>legend(...,'location',Loc)</code></p><table><thead><tr><th>Loc的值可以为：</th><th></th><th></th></tr></thead><tbody><tr><td>‘north’</td><td>‘south’</td><td>east’</td></tr><tr><td>‘west’</td><td>‘northeast’</td><td>‘northwest’</td></tr><tr><td>‘southeast’</td><td>‘southwest’</td><td>‘northoutside’</td></tr><tr><td>‘southoutside’</td><td>‘eastoutside’</td><td>‘westoutside’</td></tr><tr><td>northeastoutside’</td><td>northwestoutside’</td><td>southeastoutside’</td></tr><tr><td>southwestoutside’</td><td>‘best’</td><td>‘bestoutside’</td></tr></tbody></table><a id="more"></a><h2 id="3-坐标轴的刻度设置和标签设置"><a class="markdownIt-Anchor" href="#3-坐标轴的刻度设置和标签设置"></a> 3. 坐标轴的刻度设置和标签设置</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set(gca,<span class="string">'xtick'</span>,<span class="number">1</span>:<span class="number">1</span>:<span class="number">9</span>,<span class="string">'xticklabel'</span>,<span class="number">1</span>:<span class="number">1</span>:<span class="number">9</span>);    <span class="comment">%xtick就是要在哪些地方显示刻度，xticklabel就是显示什么</span></span><br><span class="line">set(gca,<span class="string">'ytick'</span>,<span class="number">1</span>:<span class="number">1</span>:<span class="number">9</span>,<span class="string">'yticklabel'</span>,<span class="number">1</span>:<span class="number">1</span>:<span class="number">9</span>);</span><br><span class="line">set(gca,<span class="string">'ytick'</span>,<span class="number">1</span>:<span class="number">1</span>:<span class="number">9</span>,<span class="string">'yticklabel'</span>,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;);    <span class="comment">%离散数字</span></span><br><span class="line">set(gca,<span class="string">'ytick'</span>,<span class="number">1</span>:<span class="number">1</span>:<span class="number">9</span>,<span class="string">'yticklabel'</span>,&#123;<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>&#125;);    <span class="comment">%字符串</span></span><br><span class="line">set(gca,<span class="string">'ytick'</span>,<span class="number">1</span>:<span class="number">1</span>:<span class="number">9</span>,<span class="string">'yticklabel'</span>,&#123;&#125;);    <span class="comment">%只显示刻度，不显示内容</span></span><br></pre></td></tr></table></figure><h2 id="4-figure-大小设置"><a class="markdownIt-Anchor" href="#4-figure-大小设置"></a> 4. figure 大小设置</h2><p>设置<code>position</code> 的四个参数，默认单位是像素pixel，也可以按照电脑屏幕的大小设置归一化大小。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(gcf,<span class="string">'position'</span>,[<span class="number">0.05</span>,<span class="number">0.1</span>,<span class="number">0.85</span>,<span class="number">0.75</span>],<span class="string">'Units'</span>,<span class="string">'Normalized'</span>)</span><br></pre></td></tr></table></figure><h2 id="5-其余常用命令"><a class="markdownIt-Anchor" href="#5-其余常用命令"></a> 5. 其余常用命令</h2><ul><li>栅格：<code>grid on /off</code></li><li>x坐标和y坐标说明： <code>xlabel()</code>，<code>ylabel()</code></li></ul><h1 id="绘制问题解决方案"><a class="markdownIt-Anchor" href="#绘制问题解决方案"></a> 绘制问题解决方案</h1><h2 id="1-box-on-坐标轴的右上边仍有刻度的问题"><a class="markdownIt-Anchor" href="#1-box-on-坐标轴的右上边仍有刻度的问题"></a> 1. box on 坐标轴的右上边仍有刻度的问题</h2><p>当时搜这个问题的解决方案画了很多时间，其实根本不需要去搜相关的命令，直接用<code>line([x1,x2],[y1,y2])</code>来补全就好了，也花不了多少时间</p><blockquote><p>思考可不可以用命令来获取x，y坐标轴的取值范围？python可以Matlab不知道行不行</p></blockquote><h2 id="2-设置-latex-语法以及字体"><a class="markdownIt-Anchor" href="#2-设置-latex-语法以及字体"></a> 2. 设置 latex 语法以及字体</h2><ul><li>title 、xlabel、ylabel 、zlabel、textbox 和legend 等的Interpreter 属性有三个属性： latex 、tex、none。默认为tex 。</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xlabel(<span class="string">'$\delta_w/p_w$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);</span><br><span class="line"><span class="built_in">legend</span>(&#123;string1,string2,...&#125;, <span class="string">'interpreter'</span>,<span class="string">'latex'</span>)</span><br></pre></td></tr></table></figure><ul><li>获取句柄后设置</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set(gca,<span class="string">'TickLabelInterpreter'</span>,<span class="string">'latex'</span>);  <span class="comment">% Ticklabel用的解释器好像不一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% ------------</span></span><br><span class="line">handle=<span class="built_in">legend</span>(<span class="string">'$y=x^2$'</span>,<span class="string">'$y=x^3$'</span>);    <span class="comment">%输入“latex代码格式”的图例字符串，并获取该图例的句柄</span></span><br><span class="line">set(handle, <span class="string">'interpreter'</span>,<span class="string">'latex'</span>);    <span class="comment">%把图例中字符串的解析器设置为“latex”解析器，默认是“tex”解析器</span></span><br></pre></td></tr></table></figure><ul><li>字体属性设置</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(gca,<span class="string">'Fontname'</span>,<span class="string">'latex'</span>)</span><br><span class="line">set(gca,<span class="string">'Fontsize'</span>,<span class="number">25</span>)</span><br></pre></td></tr></table></figure><h2 id="3-批量字符处理不要用方括号-用元组存取"><a class="markdownIt-Anchor" href="#3-批量字符处理不要用方括号-用元组存取"></a> 3. 批量字符处理，不要用<code>方括号[ ]</code> ，用<code>元组{}</code>存取</h2><p>因为当[ ‘string1’，‘string2’] 存取字符时，实际上存的内容为：string1string2，索引的第一元素为s，元组索引就是第一个单引号包含的内容</p><blockquote><p>注：在Matlab中输入单引号会被认为类似于char()转换字符的操作，若要输出，两个单引号等于一个单引号（功能类似于转义符\）</p></blockquote><h2 id="4-指定曲线legend输出"><a class="markdownIt-Anchor" href="#4-指定曲线legend输出"></a> 4. 指定曲线，legend输出</h2><ul><li><p>写法一：如果不指定绘制曲线句柄，legend后面可以直接跟字符串，则默认字符和曲线顺序一一对应。</p></li><li><p>写法二：给每个需要的曲线返回句柄，并单独对这些线进行设置</p></li><li><p>写法三：指定曲线不显示</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h1=<span class="built_in">plot</span>(x,y);</span><br><span class="line">set(get(get(h1,<span class="string">'Annotation'</span>),<span class="string">'LegendInformation'</span>),<span class="string">'IconDisplayStyle'</span>,<span class="string">'off'</span>);</span><br></pre></td></tr></table></figure></li><li><p>不显示legend的方框</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hl = <span class="built_in">legend</span>(H([<span class="number">1</span> <span class="number">6</span> <span class="number">11</span> <span class="number">16</span> <span class="number">21</span>],<span class="string">'1,'</span><span class="number">6</span>',<span class="string">'11’,'</span><span class="number">16</span>',<span class="string">'21'</span>);</span><br><span class="line">set(hl,<span class="string">'Box'</span>,<span class="string">'off'</span>);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
